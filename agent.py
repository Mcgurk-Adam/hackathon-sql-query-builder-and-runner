import datetime
import os
import requests
from zoneinfo import ZoneInfo
from google.adk.agents import Agent
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

def run_sql_query(query: str) -> dict:
    """Runs a SQL query, generated by the llm via the user's natural language input, in a Cloudflare D1 database via the http API.

    Args:
        query (str): The SQL query generated by the llm via the user's natural language input.

    Returns:
        dict: Every response will have the status and the query generated by the llm. If there's an error there will be an error msg. On success, "results" will hold the result of the query.
    """
    ACCOUNT_ID = "3869304b4f0b3740b3047e7ff5cf48ca"
    DATABASE_ID = "d25bd3c0-4135-4004-ba3e-4618b5b8ac4a"
    API_URL = f"https://api.cloudflare.com/client/v4/accounts/{ACCOUNT_ID}/d1/database/{DATABASE_ID}/query"
    
    api_key = os.getenv("D1_API_KEY")
    if not api_key:
        return {"status": "error", "query": query, "error": "D1_API_KEY not found in environment variables"}
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }
    payload = {"sql": query}
    
    try:
        response = requests.post(API_URL, json=payload, headers=headers)
        response.raise_for_status()
        
        response_data = response.json()
        
        if response_data and 'result' in response_data and len(response_data['result']) > 0 and 'results' in response_data['result'][0]:
            results = response_data['result'][0]['results']
        else:
            results = []
            
        return {"status": "success", "query": query, "results": results}
    except requests.exceptions.RequestException as e:
        return {"status": "error", "query": query, "error": str(e)}
    except Exception as e:
        return {"status": "error", "query": query, "error": f"Unexpected error: {str(e)}"}


root_agent = Agent(
    name="query_builder_agent",
    model="gemini-2.0-flash",
    description=(
        "Agent to build SQL queries for a crypto analytics database."
    ),
    instruction=(
        "You are a helpful agent who can take natural language and turn them into SQL prompts and then promptly run those in a D1 database. The schema of the databse is this: CREATE TABLE _cf_KV ( key TEXT PRIMARY KEY, value BLOB ) WITHOUT ROWID CREATE TABLE assets ( id INTEGER PRIMARY KEY AUTOINCREMENT, symbol TEXT NOT NULL, -- 'USDT','USDC','DAI',... llama_id TEXT, -- if you map to DeFiLlama internal id UNIQUE(symbol) ) CREATE TABLE chains ( id INTEGER PRIMARY KEY AUTOINCREMENT, gecko_id TEXT UNIQUE NOT NULL, -- e.g., 'ethereum' name TEXT NOT NULL -- e.g., 'Ethereum' ) CREATE TABLE currencies ( id INTEGER PRIMARY KEY AUTOINCREMENT, code TEXT UNIQUE NOT NULL -- 'USD','EUR','JPY',... ) CREATE TABLE data_check_history ( id INTEGER PRIMARY KEY AUTOINCREMENT, metric_type INTEGER NOT NULL, last_checked_at DATETIME DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (metric_type) REFERENCES metric_types (id) ) CREATE TABLE metric_data ( id INTEGER PRIMARY KEY AUTOINCREMENT, date TEXT NOT NULL, value REAL NOT NULL, metric_type INTEGER NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (metric_type) REFERENCES metric_types (id) ) CREATE TABLE metric_types ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL ) CREATE TABLE stablecoin_chain_constituents ( id INTEGER PRIMARY KEY AUTOINCREMENT, observed_at TEXT NOT NULL, chain_id INTEGER NOT NULL, asset_id INTEGER NOT NULL, -- references assets.symbol currency_id INTEGER NOT NULL, -- most likely USD pegged_amount REAL NOT NULL, -- token's pegged amount on the chain source TEXT NOT NULL DEFAULT 'defillama', created_at DATETIME DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (chain_id) REFERENCES chains(id), FOREIGN KEY (asset_id) REFERENCES assets(id), FOREIGN KEY (currency_id) REFERENCES currencies(id), UNIQUE (observed_at, chain_id, asset_id, currency_id) ) CREATE TABLE stablecoin_chain_totals ( id INTEGER PRIMARY KEY AUTOINCREMENT, observed_at TEXT NOT NULL, -- ISO8601 UTC, truncate to hour chain_id INTEGER NOT NULL, currency_id INTEGER NOT NULL, total_pegged REAL NOT NULL, -- value from totalCirculatingUSD.peggedXYZ source TEXT NOT NULL DEFAULT 'defillama', created_at DATETIME DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (chain_id) REFERENCES chains(id), FOREIGN KEY (currency_id) REFERENCES currencies(id), -- one row per chain/currency/hour UNIQUE (observed_at, chain_id, currency_id) ). If someone asks about USD or ETH or CPI or stablecoin data, they have exist in the database as metric types. CPI is metric type 1, USD is metric type 2, stablecoin is metric type 3, and eth is metric type 4. Importantly, in metric_data, the column named `date` is not a date field, it is a TEXT field. So when including the `metric_data.date` field in a WHERE clause, make sure to wrap it with a `DATE()` function."
    ),
    tools=[run_sql_query],
)