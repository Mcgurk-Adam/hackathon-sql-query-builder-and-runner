import datetime
import os
import requests
import re
from zoneinfo import ZoneInfo
from google.adk.agents import Agent
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Load prompt from file
def load_prompt_from_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except Exception as e:
        print(f"Error loading prompt file: {e}")
        return None

# Simple, conservative read-only gate.
# Allows: SELECT ...  and WITH ... SELECT ...
# Blocks everything else (INSERT/UPDATE/DELETE/ALTER/DROP/PRAGMA/etc.)
READONLY_RE = re.compile(
    r"""^\s*
        (?:--[^\n]*\n|\s|/\*.*?\*/)*     # leading whitespace / comments
        (?:
            SELECT\b                     # plain SELECT
          | WITH\b .*? SELECT\b          # CTE leading to SELECT
        )
    """,
    re.IGNORECASE | re.DOTALL | re.VERBOSE
)

def is_readonly_sql(sql: str) -> bool:
    # single statement only
    if ";" in sql.strip().rstrip(";"):
        return False
    return bool(READONLY_RE.match(sql))

def run_sql_query(query: str, write_ok: bool = False) -> dict:
    """Runs a SQL query, generated by the llm via the user's natural language input, in a Cloudflare D1 database via the http API.

    Args:
        query (str): The SQL query generated by the llm via the user's natural language input.
        write_ok (bool): Whether the query is a write query (INSERT, UPDATE, DELETE) or a read query (SELECT). Defaults to False.

    Returns:
        dict: Every response will have the status and the query generated by the llm. If there's an error there will be an error msg. On success, "results" will hold the result of the query.
    """
    ACCOUNT_ID = os.getenv("CLOUDFLARE_ACCOUNT_ID")
    DATABASE_ID = os.getenv("D1_DATABASE_ID")
    API_URL = f"https://api.cloudflare.com/client/v4/accounts/{ACCOUNT_ID}/d1/database/{DATABASE_ID}/query"
    
    api_key = os.getenv("D1_API_KEY")
    if not api_key:
        return {"status": "error", "query": query, "error": "D1_API_KEY not found in environment variables"}
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }
    # Gate writes unless explicitly allowed
    if not write_ok and not is_readonly_sql(query):
        return {
            "status": "error",
            "query": query,
            "error": "Write operations are disabled. Only SELECT (or WITH...SELECT) is allowed unless write_ok=True."
        }
    payload = {"sql": query}
    
    try:
        response = requests.post(API_URL, json=payload, headers=headers)
        response.raise_for_status()
        
        response_data = response.json()
        
        if response_data and 'result' in response_data and len(response_data['result']) > 0 and 'results' in response_data['result'][0]:
            results = response_data['result'][0]['results']
        else:
            results = []
            
        return {"status": "success", "query": query, "results": results}
    except requests.exceptions.RequestException as e:
        return {"status": "error", "query": query, "error": str(e)}
    except Exception as e:
        return {"status": "error", "query": query, "error": f"Unexpected error: {str(e)}"}


# Load the prompt from file
prompt_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'prompt.txt')
prompt_text = load_prompt_from_file(prompt_path)
schema_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'schema.txt')
schema_text = load_prompt_from_file(schema_path)

# If prompt loading fails, use a fallback message
if not prompt_text or not schema_text:
    full_instruction = "Error loading prompt. Please check the prompt.txt or schema.txt file."
else:
    # Concatenate the prompt text with the schema text
    full_instruction = prompt_text + schema_text

root_agent = Agent(
    name="query_builder_agent",
    model="gemini-2.0-flash",
    description=(
        "Agent to build SQL queries for a crypto analytics database."
    ),
    instruction=full_instruction,
    tools=[run_sql_query],
)