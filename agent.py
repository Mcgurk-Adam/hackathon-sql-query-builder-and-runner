import datetime
import os
import requests
import re
from zoneinfo import ZoneInfo
from google.adk.agents import Agent
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Load prompt from file
def load_prompt_from_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except Exception as e:
        print(f"Error loading prompt file: {e}")
        return None

# Simple, conservative read-only gate.
# Allows: SELECT ...  and WITH ... SELECT ...
# Blocks everything else (INSERT/UPDATE/DELETE/ALTER/DROP/PRAGMA/etc.)
READONLY_RE = re.compile(
    r"""^\s*
        (?:--[^\n]*\n|\s|/\*.*?\*/)*     # leading whitespace / comments
        (?:
            SELECT\b                     # plain SELECT
          | WITH\b .*? SELECT\b          # CTE leading to SELECT
        )
    """,
    re.IGNORECASE | re.DOTALL | re.VERBOSE
)

def is_readonly_sql(sql: str) -> bool:
    # single statement only
    if ";" in sql.strip().rstrip(";"):
        return False
    return bool(READONLY_RE.match(sql))

def run_sql_query(query: str, write_ok: bool = False) -> dict:
    """Runs a SQL query, generated by the llm via the user's natural language input, in a Cloudflare D1 database via the http API.

    Args:
        query (str): The SQL query generated by the llm via the user's natural language input.
        write_ok (bool): Whether the query is a write query (INSERT, UPDATE, DELETE) or a read query (SELECT). Defaults to False.

    Returns:
        dict: Every response will have the status and the query generated by the llm. If there's an error there will be an error msg. On success, "results" will hold the result of the query.
    """
    ACCOUNT_ID = os.getenv("CLOUDFLARE_ACCOUNT_ID")
    DATABASE_ID = os.getenv("D1_DATABASE_ID")
    API_URL = f"https://api.cloudflare.com/client/v4/accounts/{ACCOUNT_ID}/d1/database/{DATABASE_ID}/query"
    
    api_key = os.getenv("D1_API_KEY")
    if not api_key:
        return {"status": "error", "query": query, "error": "D1_API_KEY not found in environment variables"}
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }
    # Gate writes unless explicitly allowed
    if not write_ok and not is_readonly_sql(query):
        return {
            "status": "error",
            "query": query,
            "error": "Write operations are disabled. Only SELECT (or WITH...SELECT) is allowed unless write_ok=True."
        }
    payload = {"sql": query}
    
    try:
        response = requests.post(API_URL, json=payload, headers=headers)
        response.raise_for_status()
        
        response_data = response.json()
        
        if response_data and 'result' in response_data and len(response_data['result']) > 0 and 'results' in response_data['result'][0]:
            results = response_data['result'][0]['results']
        else:
            results = []
            
        return {"status": "success", "query": query, "results": results}
    except requests.exceptions.RequestException as e:
        return {"status": "error", "query": query, "error": str(e)}
    except Exception as e:
        return {"status": "error", "query": query, "error": f"Unexpected error: {str(e)}"}

def get_current_date() -> str:
    return datetime.datetime.now().strftime("%Y-%m-%d")

def get_schema() -> dict:
    """
    Fetches the current database schema from Cloudflare D1.
    Returns a dictionary keyed by table name with columns + types.
    """
    try:
        tables = run_sql_query(
            "SELECT name, sql FROM sqlite_master WHERE type='table' ORDER BY name;",
            write_ok=False
        )
        if tables["status"] != "success":
            return tables

        schema = {}
        for t in tables["results"]:
            name = t["name"]
            cols = run_sql_query(f"PRAGMA table_info({name});", write_ok=False)
            schema[name] = {
                "create_sql": t["sql"],
                "columns": cols.get("results", []),
            }

        return {"status": "success", "schema": schema}
    except Exception as e:
        return {"status": "error", "error": str(e)}

# Load the prompt from file
prompt_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'prompt.txt')
prompt_text = load_prompt_from_file(prompt_path)

root_agent = Agent(
    name="query_builder_agent",
    model="gemini-2.0-flash",
    description=(
        "Agent to build SQL queries for a crypto analytics database."
    ),
    instruction=prompt_text,
    tools=[run_sql_query, get_current_date, get_schema],
)