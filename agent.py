import datetime
import os
import requests
from zoneinfo import ZoneInfo
from google.adk.agents import Agent
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Load prompt from file
def load_prompt_from_file(file_path):
    try:
        with open(file_path, 'r') as file:
            return file.read()
    except Exception as e:
        print(f"Error loading prompt file: {e}")
        return None

def run_sql_query(query: str) -> dict:
    """Runs a SQL query, generated by the llm via the user's natural language input, in a Cloudflare D1 database via the http API.

    Args:
        query (str): The SQL query generated by the llm via the user's natural language input.

    Returns:
        dict: Every response will have the status and the query generated by the llm. If there's an error there will be an error msg. On success, "results" will hold the result of the query.
    """
    ACCOUNT_ID = "3869304b4f0b3740b3047e7ff5cf48ca"
    DATABASE_ID = "d25bd3c0-4135-4004-ba3e-4618b5b8ac4a"
    API_URL = f"https://api.cloudflare.com/client/v4/accounts/{ACCOUNT_ID}/d1/database/{DATABASE_ID}/query"
    
    api_key = os.getenv("D1_API_KEY")
    if not api_key:
        return {"status": "error", "query": query, "error": "D1_API_KEY not found in environment variables"}
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }
    payload = {"sql": query}
    
    try:
        response = requests.post(API_URL, json=payload, headers=headers)
        response.raise_for_status()
        
        response_data = response.json()
        
        if response_data and 'result' in response_data and len(response_data['result']) > 0 and 'results' in response_data['result'][0]:
            results = response_data['result'][0]['results']
        else:
            results = []
            
        return {"status": "success", "query": query, "results": results}
    except requests.exceptions.RequestException as e:
        return {"status": "error", "query": query, "error": str(e)}
    except Exception as e:
        return {"status": "error", "query": query, "error": f"Unexpected error: {str(e)}"}


# Load the prompt from file
prompt_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'prompt.txt')
prompt_text = load_prompt_from_file(prompt_path)

# If prompt loading fails, use a fallback message
if not prompt_text:
    prompt_text = "Error loading prompt. Please check the prompt.txt file."

root_agent = Agent(
    name="query_builder_agent",
    model="gemini-2.0-flash",
    description=(
        "Agent to build SQL queries for a crypto analytics database."
    ),
    instruction=prompt_text,
    tools=[run_sql_query],
)